nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
# image(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-3,by=0.25)
### Test 1.4: Newton exact method with exact GCV, default initial lambda and tolerance
output_CPP4<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.5: Newton_fd method with  exact GCV, default initial lambda and tolerance
output_CPP5<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 2: c-shaped domain ####
#            locations != nodes
#            laplacian
#            with covariates
#            no BC
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.4: Newton exact method with exact  GCV, default initial lambda and tolerance
aoutput_CPP10<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
output_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
save.image("~/new.RData")
load("~/new.RData")
library(fdaPDE)
####### 2D ########
#### Test 1: square domain ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
# image(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-3,by=0.25)
### Test 1.4: Newton exact method with exact GCV, default initial lambda and tolerance
aoutput_CPP4<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.5: Newton_fd method with  exact GCV, default initial lambda and tolerance
aoutput_CPP5<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP4$fit.FEM$coeff-aoutput_CPP4$fit.FEM$coeff))
max(abs(output_CPP5$fit.FEM$coeff-aoutput_CPP5$fit.FEM$coeff))
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.4: Newton exact method with exact  GCV, default initial lambda and tolerance
aoutput_CPP10<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
save.image("~/new.RData")
max(abs(output_CPP10$fit.FEM$coeff-aoutput_CPP10$fit.FEM$coeff))
max(abs(output_CPP11$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
load("~/new.RData")
library(fdaPDE)
####### 2D ########
#### Test 1: square domain ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
# image(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-3,by=0.25)
### Test 1.4: Newton exact method with exact GCV, default initial lambda and tolerance
aaoutput_CPP4<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.5: Newton_fd method with  exact GCV, default initial lambda and tolerance
aaoutput_CPP5<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 2: c-shaped domain ####
#            locations != nodes
#            laplacian
#            with covariates
#            no BC
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.4: Newton exact method with exact  GCV, default initial lambda and tolerance
aaoutput_CPP10<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aaoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aaoutput_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP11$fit.FEM$coeff-aaoutput_CPP11$fit.FEM$coeff))
save.image("~/new.RData")
max(abs(aoutput_CPP12$fit.FEM$coeff-aaoutput_CPP12$fit.FEM$coeff))
max(abs(aoutput_CPP10$fit.FEM$coeff-aaoutput_CPP10$fit.FEM$coeff))
max(abs(output_CPP10$fit.FEM$coeff-aaoutput_CPP10$fit.FEM$coeff))
max(abs(output_CPP5$fit.FEM$coeff-aaoutput_CPP5$fit.FEM$coeff))
max(abs(output_CPP4$fit.FEM$coeff-aaoutput_CPP4$fit.FEM$coeff))
max(abs(output_CPP4$fit.FEM$coeff-aoutput_CPP4$fit.FEM$coeff))
max(abs(output_CPP4$fit.FEM$coeff-aoutput_CPP4$fit.FEM$coeff))
max(abs(output_CPP5$fit.FEM$coeff-aoutput_CPP5$fit.FEM$coeff))
load("~/new.RData")
max(abs(aaoutput_CPP5$fit.FEM$coeff-aoutput_CPP5$fit.FEM$coeff))
max(abs(aaoutput_CPP11$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
load("~/new.RData")
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aaoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aaoutput_CPP11$fit.FEM$coeff))
load("~/new.RData")
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 2.4: Newton exact method with exact  GCV, default initial lambda and tolerance
aoutput_CPP10<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 2.3: grid with stochastic GCV
aoutput_CPP9<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
#### Test 2.2: grid with exact GCV
aoutput_CPP8<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
#### Test 2.1: Without GCV
aoutput_CPP7<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda)
### Test 2.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
aoutput_CPP12<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
load("~/new.RData")
#### Test 2: c-shaped domain ####
#            locations != nodes
#            laplacian
#            with covariates
#            no BC
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aaaoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aaaoutput_CPP11$fit.FEM$coeff))
load("~/new.RData")
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aaaoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aaaoutput_CPP11$fit.FEM$coeff))
load("~/tests_final.RData")
max(abs(output_CPP1$fit.FEM$coeff-output_CPP2ù$fit.FEM$coeff))
max(abs(output_CPP1$fit.FEM$coeff-output_CPP2$fit.FEM$coeff))
max(abs(output_CPP3$fit.FEM$coeff-output_CPP2$fit.FEM$coeff))
max(abs(output_CPP3$fit.FEM$coeff-output_CPP4$fit.FEM$coeff))
max(abs(aoutput_CPP3$fit.FEM$coeff-aoutput_CPP4$fit.FEM$coeff))
max(abs(aoutput_CPP5$fit.FEM$coeff-aoutput_CPP4$fit.FEM$coeff))
max(abs(output_CPP5$fit.FEM$coeff-output_CPP4$fit.FEM$coeff))
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
aaaoutput_CPP11<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
max(abs(output_CPP11$fit.FEM$coeff-aaaoutput_CPP11$fit.FEM$coeff))
load("~/tests_final.RData")
max(abs(output_CPP8$fit.FEM$coeff-output_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP8$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP9$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP9$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
max(abs(output_CPP9$fit.FEM$coeff-output_CPP11$fit.FEM$coeff))
max(abs(output_CPP10$fit.FEM$coeff-output_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP10$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
max(abs(output_CPP12$fit.FEM$coeff-output_CPP11$fit.FEM$coeff))
max(abs(aoutput_CPP12$fit.FEM$coeff-aoutput_CPP11$fit.FEM$coeff))
setwd("~/Università/PACS/project/fdaPDE")
check(path='.', platform='debian-gcc-release', email='beatrice1.crippa@mail.polimi.it')
library(rhub)
check(path='.', platform='debian-gcc-release', email='beatrice1.crippa@mail.polimi.it')
check(path='.', platform='ubuntu-gcc-release', email='beatrice1.crippa@mail.polimi.it')
