cov1=4*sin(2*pi*locations[,2])*cos(2*pi*locations[,3])
cov2=rnorm(nnodes*length(TimeNodes), mean=3, sd=0.1)*rep(exp(-TimeNodes/length(TimeNodes)),each=nnodes)
W=cbind(cov1,cov2)
# Fix betas
beta_exact=c(0.45,0.3)
ran=range(W%*%beta_exact + func_evaluation)
ran=range(func_evaluation)
ran = range(func_evaluation)
data = func_evaluation +rnorm(nnodes*length(TimeNodes),mean=0,sd=0.05*(ran[2]-ran[1]))
ran = range(func_evaluation+ W%*%beta_exact)
datacov=func_evaluation+ W%*%beta_exact +rnorm(nnodes*length(TimeNodes),mean=0,sd=0.05*(ran[2]-ran[1]))
data = matrix(data,nrow(mesh$nodes),length(TimeNodes))
datacov = matrix(datacov,nrow(mesh$nodes),length(TimeNodes))
#########################################SEPARABLE####################################################
asolSep = smooth.FEM.time(observations=data,
FEMbasis = FEMbasis, time_mesh = TimeNodes, time_locations = TimeNodes,
lambdaS = lambdaS, lambdaT = lambdaT,
FLAG_PARABOLIC = FALSE)
asolSepCov = smooth.FEM.time(observations=datacov, covariates = W,
FEMbasis = FEMbasis, time_mesh = TimeNodes,
lambdaS = lambdaS, lambdaT = lambdaT,
FLAG_PARABOLIC = FALSE)
##########################################PARABOLIC####################################################
### MONOLITIC METHOD
asolPar = smooth.FEM.time(observations=data,
FEMbasis = FEMbasis, time_mesh = TimeNodes, time_locations = TimeNodes,
lambdaS = lambdaS, lambdaT = lambdaT,
FLAG_PARABOLIC = TRUE)
asolParCov = smooth.FEM.time(observations=datacov[,2:length(TimeNodes)], covariates = W[(1+nrow(mesh$nodes)):(length(TimeNodes)*nrow(mesh$nodes)),],
FEMbasis = FEMbasis, time_mesh = TimeNodes,
lambdaS = lambdaS, lambdaT = lambdaT,
IC=func_evaluation[1:nrow(mesh$nodes)],
FLAG_PARABOLIC = TRUE)
#### hub areal (examples with and without covariates) ####
library(fdaPDE)
data(hub2.5Dareal)
nodesLocations=mesh$nodes
nnodes = nrow(mesh$nodes)
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
TimeNodes = 0:4
TimeNodesRMSE = seq(0,4,length.out = 15)
locations = cbind(rep(TimeNodesRMSE,each=nnodes),rep(nodesLocations[,1],length(TimeNodesRMSE)),rep(nodesLocations[,2],length(TimeNodesRMSE)),rep(nodesLocations[,3],length(TimeNodesRMSE)))
func = function(x)
{
(a1*sin(2*pi*x[,2])+a2*sin(2*pi*x[,3])+a3*sin(2*pi*x[,4])+1)*cos(x[,1])
}
func_evaluation = func(locations)
FEMbasis=create.FEM.basis(mesh)
plot(FEM.time(coeff=array(func_evaluation,dim=c(length(func_evaluation),1,1)),time_mesh = TimeNodesRMSE,FEMbasis,FLAG_PARABOLIC = T),3)
sol_exact=func_evaluation
W_areal=cbind(rep(cov_areal,length(TimeNodes))*rep(exp(-TimeNodes/length(TimeNodes)),each=RDD_groups))
beta_exact=c(1)
lambdaS=10^seq(-9, -7, 0.5)
lambdaT=10^seq(-6, -4, 0.5)
lambdaS_par=10^seq(-5.2, -4.8, 0.1)
lambdaT_par=10^seq(1, 1.8, 0.2)
obs_areal = rep(obs_areal,length(TimeNodes))*rep(cos(TimeNodes),each=RDD_groups)
ran = range(obs_areal)
data = obs_areal +rnorm(RDD_groups*length(TimeNodes),mean=0,sd=0.02*(ran[2]-ran[1]))
ran = range(obs_areal + W_areal%*%beta_exact)
datacov=obs_areal + W_areal%*%beta_exact + rnorm(RDD_groups*length(TimeNodes),mean=0,sd=0.02*(ran[2]-ran[1]))
data = matrix(data,RDD_groups,length(TimeNodes))
datacov = matrix(datacov,RDD_groups,length(TimeNodes))
###########################SEPARABLE###########################################
asolSep2 = smooth.FEM.time(observations = data,incidence_matrix = incidence_matrix, time_locations=TimeNodes,
time_mesh = TimeNodes,FEMbasis = FEMbasis,
lambdaS = lambdaS, lambdaT = lambdaT)
data(hub2.5Dareal)
nodesLocations=mesh$nodes
nnodes = nrow(mesh$nodes)
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
TimeNodes = 0:4
TimeNodesRMSE = seq(0,4,length.out = 15)
locations = cbind(rep(TimeNodesRMSE,each=nnodes),rep(nodesLocations[,1],length(TimeNodesRMSE)),rep(nodesLocations[,2],length(TimeNodesRMSE)),rep(nodesLocations[,3],length(TimeNodesRMSE)))
func = function(x)
{
(a1*sin(2*pi*x[,2])+a2*sin(2*pi*x[,3])+a3*sin(2*pi*x[,4])+1)*cos(x[,1])
}
func_evaluation = func(locations)
FEMbasis=create.FEM.basis(mesh)
plot(FEM.time(coeff=array(func_evaluation,dim=c(length(func_evaluation),1,1)),time_mesh = TimeNodesRMSE,FEMbasis,FLAG_PARABOLIC = T),3)
sol_exact=func_evaluation
W_areal=cbind(rep(cov_areal,length(TimeNodes))*rep(exp(-TimeNodes/length(TimeNodes)),each=RDD_groups))
beta_exact=c(1)
lambdaS=10^seq(-9, -7, 0.5)
lambdaT=10^seq(-6, -4, 0.5)
lambdaS_par=10^seq(-5.2, -4.8, 0.1)
lambdaT_par=10^seq(1, 1.8, 0.2)
obs_areal = rep(obs_areal,length(TimeNodes))*rep(cos(TimeNodes),each=RDD_groups)
ran = range(obs_areal)
data = obs_areal +rnorm(RDD_groups*length(TimeNodes),mean=0,sd=0.02*(ran[2]-ran[1]))
ran = range(obs_areal + W_areal%*%beta_exact)
datacov=obs_areal + W_areal%*%beta_exact + rnorm(RDD_groups*length(TimeNodes),mean=0,sd=0.02*(ran[2]-ran[1]))
data = matrix(data,RDD_groups,length(TimeNodes))
datacov = matrix(datacov,RDD_groups,length(TimeNodes))
###########################SEPARABLE###########################################
asolSep2 = smooth.FEM.time(observations = data,incidence_matrix = incidence_matrix, time_locations=TimeNodes,
time_mesh = TimeNodes,FEMbasis = FEMbasis,
lambdaS = lambdaS, lambdaT = lambdaT)
asolSepCov2 = smooth.FEM.time(observations = datacov,time_mesh = TimeNodes, covariates = W_areal,incidence_matrix = incidence_matrix,
FEMbasis = FEMbasis, lambdaS = lambdaS, lambdaT = lambdaT)
##########################################PARABOLIC####################################################
###MONOLITIC METHOD
asolPar2 = smooth.FEM.time(observations = data[,2:length(TimeNodes)],time_mesh = TimeNodes, incidence_matrix = incidence_matrix,
FEMbasis = FEMbasis, lambdaS = lambdaS_par, lambdaT = lambdaT_par, FLAG_PARABOLIC = TRUE,
IC=func_evaluation[1:nrow(mesh$nodes)])
asolParCov2 = smooth.FEM.time(observations = datacov[,2:length(TimeNodes)],time_mesh = TimeNodes, incidence_matrix = incidence_matrix,covariates = W_areal[(1+RDD_groups):(length(TimeNodes)*RDD_groups),],
FEMbasis = FEMbasis, lambdaS = lambdaS_par, lambdaT = lambdaT_par, FLAG_PARABOLIC = TRUE,
IC=func_evaluation[1:nrow(mesh$nodes)])
#### sphere 3D pointwise (with or without covariates + locations at nodes or not + stochastic GCV) ####
library(fdaPDE)
# Build mesh: Sphere
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
# plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
nnodes = nrow(sphere3D$nodes)
TimeLocations = seq(0,1,length.out = 5)
Locations = cbind(rep(TimeLocations,each=nnodes),rep(nodesLocations[,1],length(TimeLocations)),rep(nodesLocations[,2],length(TimeLocations)),rep(nodesLocations[,3],length(TimeLocations)))
# Exact test function
a1 = rnorm(1,mean = 1, sd = 1)
a2 = rnorm(1,mean = 1, sd = 1)
a3 = rnorm(1,mean = 1, sd = 1)
a4 = rnorm(1,mean = 1, sd = 1)
func = function(x)
{
a1*sin(2*pi*(x[,1]*x[,2]))+a2*cos(2*pi*x[,2])+a3*cos(2*pi*x[,3])+a4*sin(2*pi*x[,4])
}
func_evaluation = func(Locations)
ran=range(func_evaluation)
# Generate locations
nloc = 1000
loc=matrix(data=runif(3*nloc, min=-1,max=1),nrow=nloc,ncol=3,byrow=T)
ind=NULL
for(row in 1:nloc){
normvec = (loc[row,1]^2+loc[row,2]^2+loc[row,3]^2)
if(normvec>0.975)   # check points outside the sphere and remove them
ind = c(ind,row)
}
loc=loc[-ind,]
nloc=dim(loc)[1]
timeloc = seq(0,1,length.out=5)
loc = cbind(rep(timeloc,each=nloc),rep(loc[,1],length(timeloc)),rep(loc[,2],length(timeloc)),rep(loc[,3],length(timeloc)))
# Exact test function - locations different from nodes
func_evaluation2=func(loc)
cov1=(4*sin(2*pi*Locations[,2])+6*sin((2*pi*Locations[,3])^2))*(1-exp(-Locations[,1]))/3
cov2=cos(-2*pi*Locations[,4])+2*Locations[,1]*sin(2*pi*Locations[,2])/6
cov1_nonod=(4*sin(2*pi*loc[,2])+6*sin((2*pi*loc[,3])^2))*(1-exp(-loc[,1]))/3
cov2_nonod=cos(-2*pi*loc[,4])+2*loc[,1]*sin(2*pi*loc[,2])/6
W=cbind(cov1,cov2)
W2=cbind(cov1_nonod,cov2_nonod)
lambdaS=10^seq(-5.0, -4.0, 0.25)
lambdaT=10^seq(-1.5, -0.5, 0.25)
lambdaS2=10^seq(-5.5, -4.5, 0.25)
lambdaT2=10^seq(-1.5, -0.5, 0.25)
lambdaS_par=10^seq(-4.8, -4.4, 0.1)
lambdaT_par=10^seq(1.4, 1.8, 0.1)
lambdaS_par2=10^seq(-4.4, -4.0, 0.1)
lambdaT_par2=10^seq(1.4, 1.8, 0.1)
beta_exact= c(0.7,2.0)
ran = range(func_evaluation)
data = func_evaluation +rnorm(length(func_evaluation),mean=0,sd=0.05*(ran[2]-ran[1]))
ran = range(func_evaluation2)
data_noloc = func_evaluation2 +rnorm(length(func_evaluation2),mean=0,sd=0.05*(ran[2]-ran[1]))
ran = range(func_evaluation+ W%*%beta_exact)
datacov=func_evaluation+ W%*%beta_exact +rnorm(length(func_evaluation),mean=0,sd=0.05*(ran[2]-ran[1]))
data = matrix(data,nnodes,length(TimeLocations))
data_noloc = matrix(data_noloc,nloc,length(timeloc))
datacov = matrix(datacov,nnodes,length(TimeLocations))
solSep3 = smooth.FEM.time(observations = data,time_mesh = TimeLocations,
FEMbasis = FEMbasis, lambdaS = lambdaS, lambdaT = lambdaT)
solSepNoNodes = smooth.FEM.time(locations=loc[1:nloc,2:4],time_locations = timeloc,
observations = data_noloc,
time_mesh = timeloc,FEMbasis = FEMbasis,
lambdaS = lambdaS2, lambdaT = lambdaT2)
solSepCov3 = smooth.FEM.time(observations = datacov,time_mesh = TimeLocations, covariates = W,
FEMbasis = FEMbasis, lambdaS = lambdaS, lambdaT = lambdaT)
##########################################PARABOLIC####################################################
### MONOLITIC METHOD
solPar3 = smooth.FEM.time(observations = data,time_mesh = TimeLocations,
FEMbasis = FEMbasis, lambdaS = lambdaS_par, lambdaT = lambdaT_par, FLAG_PARABOLIC = TRUE)
solParNoNodes = smooth.FEM.time(locations=loc[1:nloc,2:4],observations = data_noloc,time_mesh = timeloc,
FEMbasis = FEMbasis, lambdaS = lambdaS_par2, lambdaT = lambdaT_par2, FLAG_PARABOLIC = TRUE)
solParCov3 = smooth.FEM.time(observations = datacov[,2:length(TimeLocations)],time_mesh = TimeLocations, covariates = W[(1+nnodes):(length(TimeLocations)*nnodes),],
FEMbasis = FEMbasis, lambdaS = lambdaS_par, lambdaT = lambdaT_par, FLAG_PARABOLIC = TRUE,
IC=func_evaluation[1:nnodes])
save.image("~/time.RData")
# rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc3=FEM(cos(2*pi*mesh$nodes[,2]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
plot(eigenfunc3)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff))
truecoeff<-cbind(eigenfunc1$coeff,eigenfunc2$coeff,eigenfunc3$coeff)
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_score3<-0.03
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
score3<-rnorm(n=nSamples,sd=sd_score3*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))+matrix(score3)%*%t(matrix(eigenfunc3$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
nnodes=dim(mesh$nodes)[1]
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 1.1: Without GCV
lambda = 10^-2
asol.pointwise1<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=3)
#### Test 1.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
asol.pointwise2<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Stochastic')
#### Test 1.3: K-Fold validation - Exact
asol.pointwise3<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Exact')
#### Test 1.4: GCV validation - Stochastic
asol.pointwise4<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Stochastic')
#### Test 1.5: GCV validation - Exact
asol.pointwise5<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Exact')
#### Test 2: 2D square domain ####
#            locations != nodes
#            order FE = 2
library(fdaPDE)
# rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 31)
y = x
vertex = expand.grid(x,y)
mesh = create.mesh.2D(vertex,order = 2)
FEMbasis = create.FEM.basis(mesh)
x = seq(0,1, length.out = 41)
y = x
locations = expand.grid(x,y)
ndata = dim(locations)[1]
eigenfunc1=sin(2*pi*locations[,1])
eigenfunc2=cos(2*pi*locations[,1])
eigenfunc3=cos(2*pi*locations[,2])
truedatarange<-max(c(eigenfunc1,eigenfunc2,eigenfunc3))-min(c(eigenfunc1,eigenfunc2,eigenfunc3))
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_score3<-0.03
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
score3<-rnorm(n=nSamples,sd=sd_score3*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1))+matrix(score2)%*%t(matrix(eigenfunc2))+matrix(score3)%*%t(matrix(eigenfunc3))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
error<-rnorm(n=nSamples*ndata,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 2.1: Without GCV
lambda = 10^-2
asol.pointwise6<-FPCA.FEM(locations = locations,
datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=3)
#### Test 2.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
sol.pointwise7<-FPCA.FEM(locations = locations,
datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Stochastic')
#### Test 2.3: K-Fold validation - Exact
sol.pointwise8<-FPCA.FEM(locations = locations,
datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='KFold',GCVmethod='Exact')
#### Test 2.4: GCV validation - Stochastic
sol.pointwise9<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Stochastic')
#### Test 2.5: GCV validation - Exact
sol.pointwise10<-FPCA.FEM(locations = locations,
datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Exact')
#### Test 3: 2.5D sphere domain ####
#            locations = nodes
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(sphere2.5D)
mesh<-create.mesh.2.5D(sphere2.5D$nodes, sphere2.5D$triangles)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff))
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 3.1: Without GCV
lambda = 10^-2
sol.pointwise11<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=2)
#### Test 3.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
sol.pointwise12<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Stochastic')
#### Test 3.3: K-Fold validation - Exact
sol.pointwise13<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Exact')
#### Test 3.4: GCV validation - Stochastic
sol.pointwise14<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Stochastic')
#### Test 3.5: GCV validation - Exact
sol.pointwise15<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=3,
validation='GCV',GCVmethod='Exact')
#### Test 4: 3D sphere domain ####
#            locations = nodes
#            order FE = 1
library(fdaPDE)
# rm(list=ls())
graphics.off()
data(sphere3Ddata)
mesh = create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
eigenfunc1=FEM(sin(2*pi*mesh$nodes[,1]), FEMbasis)
eigenfunc2=FEM(cos(2*pi*mesh$nodes[,1]), FEMbasis)
plot(eigenfunc1)
plot(eigenfunc2)
truedatarange<-max(c(eigenfunc1$coeff,eigenfunc2$coeff))-min(c(eigenfunc1$coeff,eigenfunc2$coeff))
set.seed(5847947)
nSamples=50
sd_score1<-0.1
sd_score2<-0.05
sd_error<-0.05
score1<-rnorm(n=nSamples,sd=sd_score1*truedatarange)
score2<-rnorm(n=nSamples,sd=sd_score2*truedatarange)
datamatrix.pointwise.exact<-matrix(score1)%*%t(matrix(eigenfunc1$coeff))+matrix(score2)%*%t(matrix(eigenfunc2$coeff))
dm.pointwise.centred.exact<-datamatrix.pointwise.exact-matrix(apply(datamatrix.pointwise.exact,2,mean),ncol=ncol(datamatrix.pointwise.exact),nrow=nrow(datamatrix.pointwise.exact),byrow=TRUE)
error<-rnorm(n=nSamples*nnodes,sd=sd_error*truedatarange)
datamatrix.pointwise<-datamatrix.pointwise.exact+error
dm.pointwise.centred<-datamatrix.pointwise-matrix(apply(datamatrix.pointwise,2,mean),ncol=ncol(datamatrix.pointwise),nrow=nrow(datamatrix.pointwise),byrow=TRUE)
#### Test 4.1: Without GCV
lambda = 10^-2
asol.pointwis16e<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,
lambda=lambda,
nPC=2)
#### Test 4.2: K-Fold validation - Stochastic
lambda = 10^c(-6,-5,-4,-3,-2)
asol.pointwise17<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Stochastic')
#### Test 4.3: K-Fold validation - Exact
asol.pointwise18<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='KFold',GCVmethod='Exact')
#### Test 4.4: GCV validation - Stochastic
asol.pointwise19<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Stochastic')
#### Test 4.5: GCV validation - Exact
asol.pointwise20<-FPCA.FEM(datamatrix=dm.pointwise.centred,
FEMbasis=FEMbasis,lambda=lambda,nPC=2,
validation='GCV',GCVmethod='Exact')
save.image("~/fpca.RData")
library(fdaPDE)
# 2D ------------------
library(fdaPDE)
# rm(list=ls())
graphics.off()
## Create a 2D mesh over a squared domain
Xbound <- seq(-3, 3, length.out = 10)
Ybound <- seq(-3, 3, length.out = 10)
grid_XY <- expand.grid(Xbound, Ybound)
Bounds <- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh <- create.mesh.2D(nodes = Bounds, order = 1)
mesh <- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis <- create.FEM.basis(mesh)
set.seed(10)
## Generate data
n <- 50
data_x <- rnorm(n)
data_y <- rnorm(n)
data <- cbind(data_x, data_y)
# 1) Cross-validation
lambda = c(0.001, 0.01, 0.1, 1)
nfolds = 5
sol1 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="RightCV")
# 2) Lambda fixed
lambda = 0.1
sol2 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 3) Cross-validation simplified version
lambda = c(0.0001, 0.001, 0.01, 0.1, 1)
nfolds = 5
sol3 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, nfolds=nfolds,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="SimplifiedCV")
# 4) Initialization given
lambda = 0.1
initF = rep(1, nrow(mesh$nodes))
sol4 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec = initF,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 5) step_method = Backtracking method
lambda = 0.1
sol5 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Backtracking_Method", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 6) step_method = Wolfe method
lambda = 0.1
sol6 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Wolfe_Method", direction_method = "BFGS",
preprocess_method="NoCrossValidation")
# 7) direction_method = Gradient
lambda = 0.1
sol7 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "Gradient",
preprocess_method="NoCrossValidation")
# 8) Naive search algorithm
lambda = 0.1
sol8 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda,
step_method = "Fixed_Step", direction_method = "BFGS",
preprocess_method="NoCrossValidation", search = "naive")
# 2.5D -------------
library(fdaPDE)
## Create a 2.5D mesh
data(sphere2.5D)
sphere<-create.mesh.2.5D(sphere2.5D$nodes, sphere2.5D$triangles)
# Normalize the sphere
sum_square = sphere$nodes[,1]^2 + sphere$nodes[,2]^2 + sphere$nodes[,3]^2
sphere$nodes[,1] = sphere$nodes[,1]  / sqrt(sum_square)
sphere$nodes[,2] = sphere$nodes[,2]  / sqrt(sum_square)
sphere$nodes[,3] = sphere$nodes[,3]  / sqrt(sum_square)
FEMbasis <- create.FEM.basis(sphere)
## Generating data
library(Directional)
mu <- c(0, -1, 0)
mu <- mu / sqrt( sum(mu^2) )
k=10
beta=0
data <- rkent(100, k, mu, beta)
plot(sphere)
pch3d(data, pch=19, cex=0.1, col="red")
## Density Estimation:
lambda = 0.01
sol9 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda)
# 3D -------------------------------------------
library(fdaPDE)
## Create a 3D mesh
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
plot(sphere3D)
FEMbasis <- create.FEM.basis(sphere3D)
## Generate data
fact = 0.01
n = 100
data_x <- fact*rnorm(n)
data_y <- fact*rnorm(n)
data_z <- fact*rnorm(n)
data <- cbind(data_x, data_y, data_z)
## Density Estimation:
lambda = 1e-5
sol10 <- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda)
save.image("~/de.RData")
