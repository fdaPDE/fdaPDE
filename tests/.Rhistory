lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
library(fdaPDE)
####### 2.5D ########
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
mesh = horseshoe2.5D
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
# Test 1.1.3: Block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, preconditioner='block_preconditioner')
# Test 1.2.3: Block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 1.3.3: Block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 1.4.3: Block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
#### Test 2: sphere domain ####
#            locations != nodes
#            with covariates
#            no BC
#            order FE = 1
library(fdaPDE)
rm(list=ls())
graphics.off()
data(sphere2.5D)
mesh = sphere2.5D
FEMbasis=create.FEM.basis(mesh)
# Test function
f = function(x, y, z){
phi = (asin(y/sqrt(x^2+y^2)))
theta = acos(z/sqrt(x^2+y^2+z^2))
# rho = 1
sin(4*(1/2*sin(theta)*exp(-sin(theta)^2)+1)*theta)*cos(2*(1/2*cos(phi)*exp(-cos(phi)^2)+1)*phi)
}
# Exact solution (pointwise at nodes)
sol_exact=f(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3])
plot(FEM(sol_exact, FEMbasis))
# Generate data locations on the sphere
set.seed(598944)
ndata = 500
locations = matrix(rnorm(ndata*3), ncol = 3)
locations = locations/sqrt(locations[,1]^2 + locations[,2]^2 + locations[,3]^2)
# Generate covariate and data
cov1 = runif(ndata, min = -1, max = 1)
DatiEsatti = f(locations[,1],locations[,2], locations[,3]) + cov1
# Add error to simulate data
set.seed(7893475)
ran=range(DatiEsatti)
data = DatiEsatti + rnorm(ndata, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Project locations on the mesh
projected_locations = projection.points.2.5D(mesh, locations)
# Set smoothing parameter
lambda = 10^seq(-4,-2,by=0.25)
# Test 2.1.3: Block preconditioner
output_CPP<-smooth.FEM(observations=data,
locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis,
lambda=lambda[1],
preconditioner='block_preconditioner')
library(fdaPDE)
####### 2D ########
#### Test 1: square domain ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
image(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-3,by=0.25)
#### Test 1.1: Without GCV
# Test 1.1.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, preconditioner='block_preconditioner')
# Test 1.2.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 1.3.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV', DOF.stochastic.realizations = 1000,
preconditioner='block_preconditioner')
# Test 1.4.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 1.5.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 1.6.3: block preconditioner
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
#### Test 2: c-shaped domain ####
#            locations != nodes
#            laplacian
#            with covariates
#            no BC
#            order FE = 1
library(fdaPDE)
rm(list=ls())
graphics.off()
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
locations = refine.mesh.2D(mesh, maximum_area = 0.05)$nodes
mesh = refine.mesh.2D(mesh, maximum_area = 0.025, minimum_angle = 30)
plot(mesh, pch = ".")
points(locations, pch = 16, col = "red")
FEMbasis = create.FEM.basis(mesh)
ndata = nrow(locations)
# Create covariates
set.seed(509875)
cov1 = rnorm(ndata, mean = 1, sd = 2)
cov2 = sin(locations[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test(locations[,1], locations[,2]) + 2*cov1 - cov2
for(ind in 1:100)
{
points(locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),1],
locations[which(round((DatiEsatti-min(DatiEsatti))/(max(DatiEsatti)-min(DatiEsatti))*100)==ind),2],
col=heat.colors(100)[ind], pch=16)
}
# Add error to simulate data
set.seed(543663)
ran = range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-3,3,by=0.25)
# Test 2.1.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
preconditioner='block_preconditioner')
# Test 2.2.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 2.3.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 2.4.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 2.5.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 2.6.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
#### Test 2.7.3: grid with stochastic GCV
output_CPP<-smooth.FEM(locations = locations, observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic',
lambda.selection.lossfunction='GCV',
PDE_parameters = PDE_parameters)
library(fdaPDE)
rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 11)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations, order = 2)
plot(mesh)
FEMbasis=create.FEM.basis(mesh)
# Test function
a1=1
a2=4
z<-function(p){
a1*sin(2*pi*p[,1])*cos(2*pi*p[,2])+a2*sin(3*pi*p[,1])}
# Exact solution (pointwise at nodes)
sol_exact=z(mesh$nodes)
image(FEM(sol_exact, FEMbasis))
DatiEsatti=z(locations)
ndati = length(DatiEsatti)
# Add error to simulate data
set.seed(7893475)
ran=range(DatiEsatti)
data = DatiEsatti + rnorm(ndati, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda= 10^seq(-6,-3,by=0.25)
# Set PDE parameters
PDE_parameters = list(K = matrix(c(1,0,0,4), nrow = 2), b = c(0,0), c = 0)
# Test 3.1.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
lambda=lambda,
PDE_parameters=PDE_parameters,
preconditioner = 'block_preconditioner')
# Test 3.2.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
lambda=lambda,
PDE_parameters=PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 3.3.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
lambda=lambda,
PDE_parameters=PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 3.4.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
PDE_parameters=PDE_parameters,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 3.5.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
PDE_parameters=PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# Test 3.6.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
FEMbasis=FEMbasis,
PDE_parameters=PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
library(fdaPDE)
rm(list=ls())
graphics.off()
data(quasicircle2Dareal)
mesh = quasicircle2Dareal$mesh
incidence_matrix = quasicircle2Dareal$incidence_matrix
DatiEsatti = quasicircle2Dareal$data
plot(mesh)
FEMbasis = create.FEM.basis(mesh)
# Add error to simulate data
set.seed(5839745)
data = DatiEsatti + rnorm(length(DatiEsatti), sd = 0.05*(max(DatiEsatti)-min(DatiEsatti)))
# Set smoothing parameter
lambda = 10^-3
# Set BC (equal to zero)
BC = NULL
BC$BC_indices = which(mesh$nodesmarkers == 1)
BC$BC_values = rep(0,length(BC$BC_indices))
# Set sv-PDE parameters
R = 2.8
K1 = 0.1
K2 = 0.2
beta = 0.5
K_func<-function(points)
{
output = array(0, c(2, 2, nrow(points)))
for (i in 1:nrow(points))
output[,,i] = 10*rbind(c(points[i,2]^2 + K1*points[i,1]^2 + K2*(R^2 - points[i,1]^2 - points[i,2]^2),
(K1-1)*points[i,1]*points[i,2]),
c((K1-1)*points[i,1]*points[i,2],
points[i,1]^2 + K1*points[i,2]^2 + K2*(R^2 - points[i,1]^2 - points[i,2]^2)))
output
}
b_func<-function(points)
{
output = array(0, c(2, nrow(points)))
for (i in 1:nrow(points))
output[,i] = 10*beta*c(points[i,1],points[i,2])
output
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(0), nrow(points))
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
# Test 4.1.1.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
preconditioner = 'block_preconditioner')
# Test 4.1.2.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner='block_preconditioner')
# Test 4.1.3.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
# Test 4.2.1.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
preconditioner = 'block_preconditioner')
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(output_CPP$fit.FEM)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
# Test 4.2.3.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
Test 4.2.4: Forcing term != 0 Newton finite differences with exact GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
# Test 4.2.4.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV',
preconditioner = 'block_preconditioner')
library(fdaPDE)
####### 3D ########
#### Test 1: square domain ####
#            locations != nodes
#            no covariates
#            no BC
#            order FE = 1
library(fdaPDE)
rm(list=ls())
graphics.off()
data(cube3D)
mesh = cube3D
plot(mesh)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Test function
f = function(x, y, z){
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact=f(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3])
plot(FEM(sol_exact, FEMbasis))
# Set locations and add error to simulate data
x = seq(0,1, length.out = 11)
y = x
z = x
locations = expand.grid(x,y,z)
DatiEsatti = f(locations[,1], locations[,2], locations[,3])
set.seed(7893475)
ran=range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda= 10^seq(-9,-7,by=1) # for simulation choose a finer grid
# Test 1.1.3: block preconditioner
output_CPP<-smooth.FEM(locations = locations,
observations=data, FEMbasis=FEMbasis, lambda=lambda[1],
preconditioner='block_preconditioner')
library(fdaPDE)
rm(list=ls())
graphics.off()
data(horseshoe3D)
mesh = horseshoe3D
FEMbasis=create.FEM.basis(mesh)
ndata = FEMbasis$nbasis
# Create covariates
set.seed(509875)
cov1=rnorm(ndata, mean = 1, sd = 2)
cov2=sin(mesh$nodes[,1])
# Exact solution (pointwise at nodes)
DatiEsatti=fs.test.3D(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3]) + 2*cov1 - cov2
plot(FEM(DatiEsatti, FEMbasis))
# Add error to simulate data
set.seed(543663)
ran=range(DatiEsatti)
data = DatiEsatti + rnorm(length(DatiEsatti), mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda= 10^seq(-3,3,by=0.25)
# Test 2.1.3: block preconditioner
output_CPP<-smooth.FEM(observations=data,
covariates = cbind(cov1, cov2),
FEMbasis=FEMbasis, lambda=lambda[1],
preconditioner='block_preconditioner')
